# -*- eval: (linum-mode 0); -*-
#+STARTUP: showeverything
* _
#+TITLE: gen_java: easy java for erlang
#+AUTHOR: Joe DeVivo
#+OPTIONS: ^:{}

** Joe DeVivo
** [[http://twitter.com/joedevivo][@joedevivo]]
** [[http://chef.io][CHEF]]

* Introduction
** I write Erlang at CHEF
** I used to write Java

* Analytics at Chef

** Stream processing of all data that flows through Chef Server.

** Used on clusters of up to 100,000 nodes!

** Sends alerts to various endpoints when various things happen
*** Hipchat
*** SMTP
*** Webhooks
*** More Coming Soon!

* Want more?

BUY MY CONFIGURATION MANAGEMENT INFRASTRUCTURE

[[http://chef.io][CHEF.io]] | [[http://docs.chef.io/analytics/][Analytics Documentation]]

* Alaska Pipeline
** Apache Storm Pipeline

** It's a pipeline, Alaska has pipelines, we called it Alaska

You write rules [[http://docs.chef.io/analytics/analytics_rules.html][Rule Documentation]]

#+BEGIN_SRC
rules 'PCI 2.3 â€“ Confirm telnet port not available'
 rule on run_control
  when
    name = 'telnet not listening' and
    resource_type = 'port' and
    resource_name = '23' and
    status != 'success'
  then
    audit:error("PCI 2.3 - Encrypt all non-console administrative \
                 access such as browser/Web-based management tools.")
    notify("security-team@financialcorp.com",
           "{{run.node_name}} is listening for connections on port 23/telnet!")
  end
end
#+END_SRC

notify(X) will use a different set of definitions for what those
messages contain.

* Parsing Rules
** Alaska Rules, an ANTLR grammar for Java
Events processed by Apache Storm pipeline

Rule syntax based on a subset of Complex Event Processing (CEP)

More info on that:

*** [[http://blog.confluent.io/2015/01/29/making-sense-of-stream-processing/][CEP Blog Post]]
*** [[http://www.espertech.com/esper/][Esper]]

* Configuration Web Service

** Erlang
** [[http://github.com/basho/webmachine][Webmachine]]
REST Framework
**  [[http://github.org/chef/sqerl][Sqerl]]
Lightweight ORM on top of epgsql

* Validating Rules
** Dave likes writing parsers, so he gave us

* Erlaska Rules
** [[https://github.com/seancribbs/neotoma][Neotoma]] Parser

Neotoma is a packrat parser-generator for Erlang for Parsing
Expression Grammars (PEGs).

The important thing being that it's different from how
ANTLR does grammars

erlaska_rules only ever validated syntax, whereas alaska_rules is an
actual compiler that generates code to evaluate in the pipeline

* erlaska_rules.erl
erlaska_rules is a module generated by the neotoma project. Once we
have that parser, validating rules from webmachine was as easy as:

#+BEGIN_SRC erlang
%% inside malformed_request/2
case erlaska_rules:parse(Rule) of
    true ->
        {false, Req, State#state{rule=Rule}};
    {false, _Reason} ->
        {true, Req, State}
end;
#+END_SRC

This worked fine at first, but every change to the grammar had to be
duplicated. Well, it turns out that we never got that far. We never
actually achieved 100% compatibility.

* What If?
We could call the Java parser from Erlang?

We've already got the ANTLR grammar, which is the definitive truth for
correctness of rules anyway. If we could use that, we cut our work in
half. Even though Dave loves parsers.

* The easy way

We could have just made a java command line tool for parsing rules,
but it just seemed like too much of a hack

* Wait
I've run Java from Erlang before with Riak_JMX. If you have to do
something twice, it's time to make it generic.

But actually, I'm doing something new here. What I really want to do
is send Java an rpc:call and have Erlang not really even care that
Java is involved.

* JInterface

It turns out we've had this for a while.

** It understands the ideas of:

*** Nodes
*** EPMD
*** Erlang Datatypes
*** Process Messages

[[http://www.erlang.org/doc/apps/jinterface/jinterface_users_guide.html][JInterface User Guide]]

[[http://www.erlang.org/doc/apps/jinterface/java/com/ericsson/otp/erlang/package-summary.html][JInterface Javadoc]]


* No RPC, No Problem

Note: My OTP source links will all be to the tag R16B03-1

I already knew that RPC calls were handled by a process called `rex`,
so I stared digging around the Erlang source for it

[[https://github.com/erlang/otp/blob/OTP_R16B03-1/lib/kernel/src/rpc.erl#L344][rpc.erl]]

#+BEGIN_SRC erlang
%% In the source for rpc.erl
-define(NAME, rex).
Result = gen_server:call({?NAME,Node}, Request, Timeout),
#+END_SRC

That's in rpc:do_call

* So, what's `Request` look like?

[[https://github.com/erlang/otp/blob/OTP_R16B03-1/lib/kernel/src/rpc.erl#L296][rpc:call]]
#+BEGIN_SRC erlang
%% rpc:call source
call(N,M,F,A,infinity) when node() =:= N ->  %% Optimize local call
    local_call(M,F,A);
call(N,M,F,A,infinity) ->
    do_call(N, {call,M,F,A,group_leader()}, infinity);
call(N,M,F,A,Timeout) when is_integer(Timeout), Timeout >= 0 ->
    do_call(N, {call,M,F,A,group_leader()}, Timeout).
#+END_SRC

* do_call

** Some RPC magic we don't need to worry about
** what we do care about is that it calls gen_server:call

[[https://github.com/erlang/otp/blob/OTP_R16B03-1/lib/kernel/src/rpc.erl#L334-L361][rpc:do_call]]

There's some pretty nifty stuff in there about spawning monitors and
trapping exits, but it's not really relevant to what we're doing here

* Request II
#+BEGIN_SRC erlang
Request = {
  call        :: atom(),
  Module      :: atom(),
  Function    :: atom(),
  Arguments   :: [any()],
  GroupLeader :: pid()
}
#+END_SRC

* But wait, there's more
That's not all Erlang would be sending to another node. Let's dig into the gen_server:call

** PEEVE: rpc is in kernel, but gen_server is in stdlib

[[https://github.com/erlang/otp/blob/OTP_R16B03-1/lib/stdlib/src/gen_server.erl#L168-L189][gen_server:call]]

#+BEGIN_SRC erlang
call(Name, Request, Timeout) ->
    case catch gen:call(Name, '$gen_call', Request, Timeout) of
	{ok,Res} ->
	    Res;
	{'EXIT',Reason} ->
	    exit({Reason, {?MODULE, call, [Name, Request, Timeout]}})
    end.
#+END_SRC

Ahhh, the rabbit hole goes deeper.

* gen:call

Source: [[https://github.com/erlang/otp/blob/OTP_R16B03-1/lib/stdlib/src/gen.erl#L134-L243][gen:call]]

#+BEGIN_SRC erlang
%% deep in gen:do_call, which is called by gen:call
erlang:send(Process, {Label, {self(), Mref}, Request},
		  [noconnect])
#+END_SRC

Jackpot! The second argument to erlang:send/3 is our message!
The actual message being sent is a 3-tuple

* 1st element

#+BEGIN_SRC erlang
'$gen_call'
#+END_SRC

* 2nd element

#+BEGIN_SRC erlang
{ From :: pid(),
  MRef :: ref() }
#+END_SRC

From pid could be waiting for a bunch of replies.
MRef let's it know what it's a reply to

* 3rd element

Request from above

#+BEGIN_SRC erlang
Request = {
  call        :: atom(),
  Module      :: atom(),
  Function    :: atom(),
  Arguments   :: [any()],
  GroupLeader :: pid()
}
#+END_SRC

* Now we know what erlang sends to other erlang nodes for rpc:call

* Setting up the Java Side

JInterface gives us Node for free, so we can just set something up to
listen for messages

#+BEGIN_SRC java
public static void main(String[] stringArgs) throws Exception {
    String nodename = stringArgs[0];
    String cookie = stringArgs[1];
    OtpNode self = new OtpNode(nodename, cookie);
    boolean keepGoing = true;
    OtpMbox rex = self.createMbox("rex");
    while(keepGoing) {
        // rex.receive is a blocking call,
        //so just hang out here until one shows up
        OtpErlangObject o = rex.receive();
        System.out.println("Rex received '"
                           + o.toString());
    }
}
#+END_SRC

The Simplest of Java nodes. Just opens up a `rex` mailbox and waits
for messages. Any rpc:call to this node will just print it's content
to stdout.

* Deserialization in Java
This is where we start missing pattern matching. It takes about 50
lines of Java to parse out that 3-tuple that gen:do_call is sending
over. And that's with Exception handling abstracted out

Source [[https://github.com/joedevivo/gen_java/blob/0.1.2/src/main/java/com/devivo/gen_java/ErlangRemoteProcedureCallMessage.java#L20-L77][ErlangRemoteProcedureCallMessage.java]]

* Validate Arity
#+BEGIN_SRC java
OtpErlangTuple rexCall = (OtpErlangTuple)o;
int arity = rexCall.arity();
if (arity != 3) {
    throw new Exception(
       "Rex message has invalid arity. expected 3, got "
       + arity);
}
#+END_SRC

* Validate gen_call as first element:

Remember the 1st element? '$gen_call'

#+BEGIN_SRC java
OtpErlangAtom gen_call = (OtpErlangAtom)(rexCall.elementAt(0));
String gen_call_string = gen_call.atomValue();
if (!gen_call_string.equals("$gen_call")) {
    throw new Exception(
        "Rex message should start with '$gen_call': "
        + o.toString());
}
#+END_SRC

* Validate second element: {Pid::pid, Ref::ref}
#+BEGIN_SRC java
OtpErlangTuple fromTuple = (OtpErlangTuple)(rexCall.elementAt(1));
int fromArity = fromTuple.arity();
if (fromArity != 2) {
    throw new Exception(
        "Rex message's 'from' tuple should have 2 elements, has "
         + fromArity + ": " + o.toString());
}
this.fromPid = (OtpErlangPid)(fromTuple.elementAt(0));
this.fromRef = (OtpErlangRef)(fromTuple.elementAt(1));
#+END_SRC

* Validate the call tuple:
{call::atom, Mod::atom, Fun::atom, List::list(), user:atom()}
#+BEGIN_SRC java
OtpErlangTuple callTuple = (OtpErlangTuple)(rexCall.elementAt(2));
int callArity = callTuple.arity();
if (callArity != 5) {
    throw new ErlangRemoteException(this.fromPid, this.fromRef,
              "Rex message's 'call' tuple should have 5 elements, has "
               + callArity + ": " + o.toString());
}
OtpErlangAtom callAtom = (OtpErlangAtom)(callTuple.elementAt(0));
String callString = callAtom.atomValue();
if (!callString.equals("call")) {
    throw new ErlangRemoteException(this.fromPid, this.fromRef,
              "Rex message's call block should start with 'call', but it's : "
               + callString);
}
#+END_SRC

* Validate M,F,A
#+BEGIN_SRC java
try {
    this.mfa = new ErlangModFunArgs(
        (OtpErlangAtom)(callTuple.elementAt(1)),
        (OtpErlangAtom)(callTuple.elementAt(2)),
        (OtpErlangList)(callTuple.elementAt(3)));
    this.remoteGroupLeaderPid = (OtpErlangPid)(callTuple.elementAt(4));
} catch (Exception e) {
    throw new ErlangRemoteException(this.fromPid, this.fromRef, e);
}
#+END_SRC

* Exception Handling: toErlangException
Source: [[https://github.com/joedevivo/gen_java/blob/0.1.2/src/main/java/com/devivo/gen_java/ErlangRemoteException.java][ErlangRemoteException.java]]

turns exceptions into {error, "Message"}

#+BEGIN_SRC java
public static OtpErlangObject toErlangException(Exception e) {
    OtpErlangObject[] elements = new OtpErlangObject[2];
    elements[0] = new OtpErlangAtom("error");
    elements[1] = new OtpErlangString(e.getMessage());
    return new OtpErlangTuple(elements);
}
#+END_SRC

* Exception Handling: send
send knows just enough about erlang/rex to send
an error message back to rpc:call

We forgot to look at that! Fortunately it's here in [[https://github.com/erlang/otp/blob/OTP_R16B03-1/lib/stdlib/src/gen.erl#L211-L214][gen:do_call]]

It's waiting for a
#+BEGIN_SRC erlang
{ref(), Reply}
#+END_SRC
So we send
#+BEGIN_SRC java
public void send(OtpMbox mbox) {
    OtpErlangObject[] elements = new OtpErlangObject[2];
    elements[0] = this.fromRef;
    elements[1] = this.toErlangException();
    mbox.send(this.fromPid, new OtpErlangTuple(elements));
}
#+END_SRC

* But, sometimes not.

If you noticed, we don't start using ErlangRemoteException until after
we've read in the second tuple. It's not until then that we know
enough about the sender to know where to send the reply. Before that,
we just throw regular exceptions. We'll catch both types when we
process incoming messages. If we don't know how to respond, we'll just
dump the output to the console, which we'll teach the erlang side to
monitor.

[[https://github.com/joedevivo/gen_java/blob/0.1.2/src/main/java/com/devivo/gen_java/ErlangServer.java#L104-L125][Java incoming message processing]]

#+BEGIN_SRC java
ErlangRemoteProcedureCallMessage msg = null;

try {
    msg = new ErlangRemoteProcedureCallMessage(rex, o);
} catch (ErlangRemoteException erlE) {
    erlE.send(rex);
} catch (Exception e) {
    System.out.println("Rex received '"
        + o.toString()
        + "' but didn't know how to process it. Exception: "
        + e.getMessage());
}
#+END_SRC

* Back to the Erlang side

* The gen_java module

** It's a gen_server
** Starts a jar of your choosing!
** When you build that jar, include gen_java.jar

* The gen_java project structure

** src/main/java <- maven will build a jar with this
** src/main/erlang <- rebar will use this

* Starting the gen_java server

Opens a port running your jar in the JVM

* Basic Handshake

#+BEGIN_SRC erlang
case wait_until(
        fun() ->
            X = rpc:call(Nodename, erlang, node, [], 10000),
            lager:debug(
                "[gen_java][~p] rpc:call(~p, erlang, node, []) = ~p",
                [Module, Nodename, X]),
            Nodename = : = X
        end, 20, 1000) of
    ok ->
        rpc:call(Nodename, erlang, link, [self()]),
        erlang:monitor_node(Nodename, true),
        init_callback( State#gen_java_state{ port = Port, pid = Pid});
    timeout ->
        {stop, timeout}
end
#+END_SRC

#+CAPTION: that's so fetch
[[./img/Mean-Girls-stop-trying-to-make-fetch-happen.gif]]

* Handshake II

** keeps rpc calling erlang:node/0 until it gets an answer
** if it doesn't stop the server, otherwise
** link the java node back to the server's process
** monitor the java node
** init_callback?
After we've started, there's a callback that lets you run some startup
java code before we start accepting rpc:calls

* Error logging

[[https://github.com/joedevivo/gen_java/blob/master/src/main/erlang/gen_java.erl#L150-L152][handle_info/2]]

#+BEGIN_SRC erlang
handle_info({Port, {data, {_Type, Data}}},
            #gen_java_state { port = Port, module = M } = State) ->
    lager:info("[gen_java][~p] ~s", [M, Data]),
    {noreply, State};
#+END_SRC

Now that we've got a port running this JVM anything that java
System.out.printlns will end up in your erlang application's log

* Recap

** We're sending rpc:calls to the java node
** we can send error messages back
*** console
*** rpc responses

* So, what do we do with actual rpc calls?

* The Easy Way : Hard Coded

There are somethings we just want every java node to be able to do:

* Needed by our Handshake
** erlang:node/0
** erlang:link/1

* POC Methods
** erlang:abs/1

* Nice for JVM inspection
** java:system_properties/0
** java:system_env/0
** java:input_args/0

* WTF is the java module?!

I made it up. I made the erlang module up to. Java doesn't have these

Let's talk about how we map erlang MFAs

* Needed by our Handshake
erlang:link/1 and erlang:node/0 are special cases because they need
information about our java node's state as a JInterface.

* All Others
** must be java methods of type public static final
** must have all arguments and return types of classes provided by JInterface
** since java reflection is a bit expensive, we cache the Method objects.

* Initializing the RPC Method Cache

#+BEGIN_SRC java
Map<ErlangFunctionCacheKey, Method> RPCCache =
    new HashMap<ErlangFunctionCacheKey, Method>();
RPCCache.put(
        new ErlangFunctionCacheKey(
                "erlang", "abs", OtpErlangDouble.class),
        Erlang.class.getMethod("abs", OtpErlangDouble.class));
RPCCache.put(
        new ErlangFunctionCacheKey(
                "erlang", "abs", OtpErlangLong.class),
        Erlang.class.getMethod("abs", OtpErlangLong.class));
#+END_SRC

last arg is variable list of classes

* dat java module

#+BEGIN_SRC java
// wrapper for java.util.System.getProperties()
RPCCache.put(
        new ErlangFunctionCacheKey("java", "system_properties"),
        Java.class.getMethod("system_properties"));

RPCCache.put(
        new ErlangFunctionCacheKey("java", "system_env"),
        Java.class.getMethod("system_env"));

RPCCache.put(
        new ErlangFunctionCacheKey("java", "input_arguments"),
        Java.class.getMethod("input_arguments"));
#+END_SRC

* What about your own methods?

** Module: Full Java Classname
** Function: Java Method Name
** Args: ARGS!

* Caching?
[[https://github.com/joedevivo/gen_java/blob/0.1.2/src/main/java/com/devivo/gen_java/ErlangServer.java#L145-L165][check the cache]]

#+BEGIN_SRC java
if(RPCCache.containsKey(msg.getMFA().getKey())) {
    Method m = RPCCache.get(msg.getMFA().getKey());
    msg.setMethod(m);
    pool.execute(msg);

} else {
    // This means it's not in the cache, we should
    // try and find it and add it.
    Method m = find(msg.getMFA().getKey());
    if (m != null) {
        RPCCache.put(msg.getMFA().getKey(), m);
        msg.setMethod(m);
        pool.execute(msg);
    } else {
        System.out.println("Bad RPC: " +
            msg.getMFA().getKey().toString());
        // we couldn't add it, be nice and send a badrpc error back
        msg.send(msg.toErlangBadRPC());
    }
}
#+END_SRC

* msg.toErlangBadRPC()

[[https://github.com/joedevivo/gen_java/blob/master/src/main/java/com/devivo/gen_java/ErlangRemoteProcedureCallMessage.java#L94-L139][toErlangBadRPC()]]

#+BEGIN_SRC erlang
% Bad RPC calls look like this:
{badrpc,{'EXIT',{undef,[{Module,Fun,[],[]},
                {rpc,'-handle_call_call/6-fun-0-',5,
                     [{file,"rpc.erl"},{line,205}]}]}}}
#+END_SRC

So we construct that tuple as a repsonse and send it

* Payoff!

Reflection is only done once per method.

* We're aiming for the pool, right?

#+BEGIN_SRC java
pool.execute(msg);
#+END_SRC

We went ahead and added some thread pooling on the java side.

Otherwise all the processing happening in once place.
what if you asked it to do hard things?

[[https://github.com/joedevivo/gen_java/blob/master/src/main/java/com/devivo/gen_java/ErlangRemoteProcedureCallMessage.java#L146-L157][pool.execute()]] is where we package up the method's return value and
send it back to Erlang.

#+BEGIN_SRC java
public void run() {
    OtpErlangObject result = new OtpErlangAtom("null");
    try {
        result = (OtpErlangObject)
            this.method.invoke(null, getMFA().getArgs().elements());
    } catch (Exception e) {
        // This could "technically" throw a InvocationTargetException
        // or an IllegalAccessException. We'll write defensive code
        // for that eventually
        System.out.println(e.getClass().getName() + " : " + e.getMessage());
        result = error(e.getClass().getName() + " : " + e.getMessage());
    }
    this.send(result);
}
#+END_SRC

* Wraping Responses
#+BEGIN_SRC java
public void send(OtpErlangObject resp) {
    this.rex.send(this.fromPid, wrapResponse(resp));
}

public OtpErlangTuple wrapResponse(OtpErlangObject resp) {
    OtpErlangObject[] elements = new OtpErlangObject[2];
    elements[0] = this.fromRef;
    elements[1] = resp;
    return new OtpErlangTuple(elements);
}
#+END_SRC

this.send makes sure to send it to the right place

wrapResponse makes sure to include that ref() we need for RPC

* Erlang Developer Experience

You might remember that I'm kind of a user experience nut

[[http://github.com/basho/cuttlefish][Cuttlefish]]

* Your Java Module

#+BEGIN_SRC erlang
-module(my_java).
-compile({parse_transform, gen_java_parse_transform}).
#+END_SRC

* Your sys.config
#+BEGIN_SRC erlang
[{gen_java, [
     {modules, [
         {my_java, [
             {jar, "/path/to/my.jar"},
             {thread_count, 10}
                        ]}
               ]}
            ]}
].
#+END_SRC

* Your Supervisor

** start it with my_java:start_link/0 or
#+BEGIN_SRC erlang
{my_java,
    {my_java, start_link, []},
    permanent, 5000, worker, [my_java]},
#+END_SRC

* init callback
Remember that? put it here, it'll get called right after the handshake

#+BEGIN_SRC erlang
-spec init(atom()) -> ok.
init(Nodename) ->
    SomeState = {some, thing, maybe_a_file_path},
    rpc:call(Nodename, 'com.yourcompany.package', 'init', [SomeState]).
#+END_SRC

* Parse Transform

** wrappers for gen_server:call

#+BEGIN_SRC erlang
17 = my_java:call(erlang, abs, [-17]).
<<"your heart's desire">> = my_java:call('com.my.package','myMethod',[]).
#+END_SRC

* How it does it
 Simple parse transforms are easy

[[https://github.com/joedevivo/gen_java/blob/master/src/main/erlang/gen_java_parse_transform.erl][gen_java_parse_transform.erl]]

This whole file just looks for a module's name, and subs it in to 5
functions

* 5 Functions

#+BEGIN_SRC erlang
-export([start_link/0,start/0,call/3,call/4,stop/0]).

stop() ->
    gen_java:stop(my_java).

call(Module, Function, Args, Timeout) ->
    gen_java:call(my_java, Module, Function, Args, Timeout).

call(Module, Function, Args) ->
    gen_java:call(my_java, Module, Function, Args).

start() ->
    gen_java:start(my_java).

start_link() ->
    gen_java:start_link(my_java).
#+END_SRC

* That's it!

** Let's look at one

#+BEGIN_SRC erlang
func({call, 4}, L, #state{module=Module}) ->
      {function,L,call,4,
          [{clause,L,
               [{var,L,'Module'},{var,L,'Function'},{var,L,'Args'},{var,L,'Timeout'}],
               [],
               [{call,L,
                    {remote,L,{atom,L,gen_java},{atom,L,call}},
                    [{atom,L,Module},
                     {var,L,'Module'},
                     {var,L,'Function'},
                     {var,L,'Args'},
                     {var,L,'Timeout'}]}]}]}.
#+END_SRC

There's only two variables in that whole mess

** L : The line number at which this code goes
** Module: The name of the module we're calling

* Generated Function

#+BEGIN_SRC erlang
call(Module, Function, Args, Timeout) ->
    gen_java:call(my_java, Module, Function, Args, Timeout).
#+END_SRC

* Abstract Forms

All that gobbledy gook is an Abstract Form. You can make Artesianal
Handcrafted Abstract Forms, but for things like this there's an
easier way

#+BEGIN_SRC erlang
F = fun(S) ->
    {ok, T, _} = erl_scan:string(S),
    {ok, AbsForm} = erl_parse:parse_form(T),
    AbsForm
end.
#+END_SRC

* Your own Abstract Form
#+BEGIN_SRC erlang
F("call(Module, Function, Args, Timeout) ->
    gen_java:call(my_java, Module, Function, Args, Timeout).").
{function,1,call,4,
          [{clause,1,
                   [{var,1,'Module'},
                    {var,1,'Function'},
                    {var,1,'Args'},
                    {var,1,'Timeout'}],
                   [],
                   [{call,2,
                          {remote,2,{atom,2,gen_java},{atom,2,call}},
                          [{atom,2,my_java},
                           {var,2,'Module'},
                           {var,2,'Function'},
                           {var,2,'Args'},
                           {var,2,'Timeout'}]}]}]}

#+END_SRC

To add it to your own parse transform, you just have to sub all those
1's and 2's with L and all those my_java's with Module


* Adding convenience

#+BEGIN_SRC erlang
-spec my_method(binary()) -> binary() | gen_java:badrpc().
my_method(Binary) ->
    call('com.my.package','myMethod',[Binary]).
#+END_SRC

* Then using java in your app is as easy as
#+BEGIN_SRC erlang
my_java:my_method(Binary).
#+END_SRC

* Bringing it Back to CHEF Analytics

** erlaska_rules is out!
** alaska_rules.jar is in!

* sys.config
#+BEGIN_SRC erlang
[{gen_java, [
     {modules, [
         {alaska_rules, [
             {jar, "priv/alaska_rules.jar"},
             {thread_count, 10}
                        ]}
               ]}
            ]}
].
#+END_SRC

* alaska_rules.erl

#+BEGIN_SRC erlang
-module(alaska_rules).

-compile({parse_transform, gen_java_parse_transform}).

-export([valid_rule/1, valid_rule_group/1, init/1]).

-spec valid_rule(binary()) -> true | {error, string()} | gen_java:badrpc().
valid_rule(Bin) ->
    call('com.chef.analytics.rules.erlang.RuleValidator', 'validRule', [Bin]).

-spec valid_rule_group(binary()) -> true | {error, string()} | gen_java:badrpc().
valid_rule_group(Bin) ->
    call('com.chef.analytics.rules.erlang.RuleValidator', 'validRuleGroup', [Bin]).
#+END_SRC

* init/1

We have some JSON schemas that alaksa_rules.jar uses for validation of attributes.

init/1 reads them in as a list of binaries and then sends them over to the java node

#+BEGIN_SRC erlang
init(Nodename) ->
    Dir = schema_dir(),
    JSONSchemas = filelib:wildcard(filename:join([Dir, "*.json"])),
    Schemas = [begin
                   {ok, Bin} = file:read_file(Filename),
                   {list_to_atom(filename:basename(Filename)), Bin}
               end || Filename <- JSONSchemas],
    rpc:call(Nodename,
             'com.chef.analytics.rules.erlang.RuleValidator', 'setSchemas', [Schemas]),
    ok.
#+END_SRC

* Bringing it back to WebMachine

#+BEGIN_SRC erlang
case alaska_rules:valid_rule_group(nc_obj_rule:getval(rule, Rule)) of
    true ->
        lager:debug("malformed_request: rule syntax good"),
        {false, Req, State};
    {error, Msg} ->
        lager:debug("Invalid rule syntax: ~s", [Msg]),
        mf_return(Msg, [], Req, State);
    {badrpc, nodedown} ->
        lager:error("Alaska Rules node down, no validation possible"),
        NewReq = req_helper([
            {set_resp_header, ["content-type", "application/json"]},
            {set_resp_body, [jiffy:encode(
                {[{error, <<"server side validation error">>}]})]}
        ], Req),
        {{halt, 500}, NewReq, State}
end.
#+END_SRC

* Wraping Up
 All in all, this is just a wrapper for the hard stuff Erlang gave us
 for free. But what if they didn't?

* Erlang Haskell Interface
[[https://github.com/joedevivo/erlang-haskell-interface][github source]]

* Erlang gives you zero Haskell for free

But somebody did: [[http://hackage.haskell.org/package/erlang-0.1][hackage erlang-0.1]]

* What I got:

* Erlang Types

#+BEGIN_SRC haskell
data ErlType = ErlNull
             | ErlInt Int
             | ErlBigInt Integer
             | ErlString String
             | ErlAtom String
             | ErlBinary [Word8]
             | ErlList [ErlType]
             | ErlTuple [ErlType]
             | ErlPid ErlType Int Int Int     -- node id serial creation
             | ErlPort ErlType Int Int        -- node id creation
             | ErlRef ErlType Int Int         -- node id creation
             | ErlNewRef ErlType Int [Word8]  -- node creation id
             deriving (Eq, Show)
#+END_SRC

* Packing functions
#+BEGIN_SRC haskell
putC = putWord8 . fromIntegral
putn = putWord16be . fromIntegral
putN = putWord32be . fromIntegral
puta = putByteString . B.pack
putA = putByteString . C.pack

getC = liftM fromIntegral getWord8
getn = liftM fromIntegral getWord16be
getN = liftM fromIntegral getWord32be
geta = liftM B.unpack . getByteString
getA = liftM C.unpack . getByteString
#+END_SRC

* Half a Protocol
Looks like erlang-0.1 knew how to connect to an Erlang node from Haskell

It wanted it one way, but I wanted the other

* Getting the old one working
nano-md5 dependency didn't work anymore, so replaced with PureMD5

[[https://wiki.haskell.org/Applications_and_libraries/Interfacing_other_languages/Erlang][Existing Documentation]] wasn't great

* Spinning up a Haskell Erlang node

[[https://github.com/joedevivo/erlang-haskell-interface/blob/master/Test.hs#L17-L30][start]]

#+BEGIN_SRC haskell
start nodename = do
    setupLoggers DEBUG

    infoM "Test" $ "Starting Node: " ++ nodename
    self <- createSelf nodename
    mbox <- createMBox self
    debugM "Test" $ "mbox: " ++ (show mbox)

    -- Rex spawned here, because it's our job as consumers of this
    -- module to consume these
    forever $ do
    rex_mbox <- createNamedMBox "rex" self
    forkIO $ rex rex_mbox
    return ()
#+END_SRC

* createSelf

[[https://github.com/joedevivo/erlang-haskell-interface/blob/master/src/Foreign/Erlang/Processes.hs#L66-L79][Processes.hs]]

#+BEGIN_SRC haskell
-- | Instantiate a Haskell node.  This initializes the FFI.
createSelf          :: String -> IO Self
createSelf nodename = do
    inbox <- newEmptyMVar
    forkIO $ serve nodename inbox
    forkIO $ self nodename inbox

    node <- return .  Self $ putMVar inbox

    -- Try spawning net_kernel mbox
    nk_mbox <- createNamedMBox "net_kernel" node
    forkIO $ net_kernel nk_mbox

    return node  --Self $ putMVar inbox
#+END_SRC

serve is the function that connects to epmd, opens up a listener and then puts messages in a mbox

self is the thing that routes those messages

* serve

* Learning EPMD
[[http://www.erlang.org/doc/man/epmd.html][epmd]]
[[http://www.erlang.org/doc/apps/erts/erl_dist_protocol.html][protocol documentation]]

* Reserving a port
EMPD_ALIVE2_REQ

Open a socked with this request and keep it open... forever.

Here's the message EPMD expects

|Bytes | Content                              |
|------+--------------------------------------|
| 1    | 120                                  |
| 2    | Port to reserve                      |
| 1    | 77 (means normal erlang node)        |
| 1    | Protocol (0 = tcp/ipv4)              |
| 2    | Highest version (5 = R6B and higher) |
| 2    | Lowest version (5 = R6B and higher)  |
| 2    | Length in bytes of nodename field    |
| X    | Nodename, X = ^^                     |
| 2    | Length of Extras, we used 0          |
| Y    | Extras, length ^^, but we sent none  |

* What's that look like?
#+CAPTION: Wiretap of ALIVE2_REQ
 [[./img/EPMD_ALIVE2_REQ.png]]

#+CAPTION: Bytes of ALIVE2_RESP
[[./img/EPMD_ALIVE2_RESP.png]]

* Haskell Does It
#+BEGIN_SRC haskell
epmdAlive2Req :: String -> Int -> IO ()
epmdAlive2Req node port = withEpmd $ \hdl -> do
    let msg = runPut $ tag 'x' >>
                       putn port >>
                       putC 77 >> -- node type
                       putC 0 >>  -- protocol
                       putn erlangVersion >>
                       putn erlangVersion >>
                       putn (length node) >>
                       putA node >>
                       putn 0 -- "Extra" length, 0 for none
    let len = fromIntegral $ B.length msg
    let out = runPut $ putn len >> putLazyByteString msg
    forever $ do
    B.hPut hdl out
    hFlush hdl
    B.hGetContents hdl
    return ()
#+END_SRC

See that forever call. just hang out letting EPMD know you still love it.

TIL: You can run `empd -debug` to see what's coming across the wire through EPMD

* The Distribution Handshake
[[http://www.erlang.org/doc/apps/erts/erl_dist_protocol.html#id92374][Handshake Documentation]]

ALIVE2_REQ isn't even a quarter of the handshake.

We also have to do a back and forth over the port we're actually listening on

#+BEGIN_SRC
send_name            ------>            recv_name

recv_status          <------          send_status

send_status          ------>          recv_status

recv_challenge       <------       send_challenge

send_challenge_reply ------> recv_challenge_reply

recv_challege_ack    <------   send_challenge_ack
#+END_SRC

#+CAPTION: Here's an example of SEND_NAME
[[./img/SEND_NAME.png]]

Let's gloss over this. If you want to see it, I did it here: [[https://github.com/joedevivo/erlang-haskell-interface/blob/master/src/Foreign/Erlang/Network.hs#L197-L248][Network.hs]]

** Funky Middle Syntax

[[http://www.erlang.org/doc/apps/erts/erl_dist_protocol.html#id92768][Protocol between connected nodes]]

Turns out we need to figure out how to interpret Erlangy packets coming in now

Here's the distilled version of what they could be:

#+BEGIN_SRC erlang
{1, FromPid, ToPid}                       %% LINK
{2, Cookie, ToPid}                        %% SEND
{3, FromPid, ToPid, Reason}               %% EXIT
{4, FromPid, ToPid}                       %% UNLINK
{5}                                       %% NODE_LINK
{6, FromPid, Cookie, ToName}              %% REG_SEND
{7, FromPid, ToPid}                       %% GROUP_LEADER
{8, FromPid, ToPid, Reason}               %% EXIT2
{12, Cookie, ToPid, TraceToken}           %% SEND_TT
{16, FromPid, Cookie, ToName, TraceToken} %% REG_SEND_TT
{18, FromPid, ToPid, TraceToken, Reason}  %% EXIT2_TT
{19, FromPid, ToProc, Ref}                %% MONITOR_P
{20, FromPid, ToProc, Ref}                %% DEMONITOR_P
{21, FromProc, ToPid, Ref, Reason}        %% MONITOR_P_EXIT
#+END_SRC

* Here's how the self process is handling them

Full Function: [[https://github.com/joedevivo/erlang-haskell-interface/blob/master/src/Foreign/Erlang/Processes.hs#L81-L174][Processes.hs]]

#+BEGIN_SRC haskell
self                :: String -> MVar ErlMessage -> IO ()
self nodename inbox = loop 1 [] [] []
  where
    loop id registered mboxes nodes = do
        msg <- takeMVar inbox
        debugM "Foreign.Erlang.Processes" $ "loop msg recv'd: " ++ (show msg)
        case msg of
          ErlSend node pid msg -> do
            let ctl = toErlang (ErlInt 2, ErlAtom "", pid)
            (mnode, nodes') <- findNode node nodes
            case mnode of
              Just n  -> n (Just ctl, Just msg)
              Nothing -> return ()
            loop id registered mboxes nodes'
          ErlRegSend from node pid msg -> do
            let ctl = toErlang (ErlInt 6, from, ErlAtom "", ErlAtom pid)
            (mnode, nodes') <- findNode node nodes
            case mnode of
              Just n  -> n (Just ctl, Just msg)
              Nothing -> return ()
            loop id registered mboxes nodes'
          ErlDispatch ctl msg -> do
            case ctl of
              ErlTuple [ErlInt 2, _, pid] ->
                maybe (return ()) ($ msg) $ lookup pid mboxes
              ErlTuple [ErlInt 6, from, _, pid] ->
                maybe (return ()) ($ (ErlTuple [from, msg])) $ lookup pid registered
              _ -> return ()
            loop id registered mboxes nodes
          -- This clause is for when Erlang has connected to this node
          -- we're just telling this node to add it to the connected nodes.
          ConnectedNode to node -> do
            case lookup to nodes of
                Just n ->
                  loop id registered mboxes nodes
                Nothing ->
                  loop id registered mboxes ((to, node):nodes)
          ErlStop -> return ()

#+END_SRC

* An rpc:call received by Haskell

#+BEGIN_SRC erlang
erlang: rpc:call('haskell@127.0.0.1', 'mod', 'fun', ['args']).
#+END_SRC

#+BEGIN_SRC haskell
ErlPid (ErlAtom "erlang@127.0.0.1") 38 0 2
ErlTuple [ErlAtom "$gen_call",
          ErlTuple [ErlPid (ErlAtom "erlang@127.0.0.1") 38 0 2,
                    ErlNewRef (ErlAtom "erlang@127.0.0.1") 2 [0,0,0,191,0,0,0,0,0,0,0,0]],
          ErlTuple [ErlAtom "call",
                    ErlAtom "mod",
                    ErlAtom "fun",
                    ErlList [ErlAtom "args"],
                    ErlPid (ErlAtom "erlang@127.0.0.1") 31 0 2]]
#+END_SRC

This should look familiar

* The Rex mbox

[[https://github.com/joedevivo/erlang-haskell-interface/blob/master/Test.hs#L32-L60][Test.hs:rex mbox]]

#+BEGIN_SRC haskell
rex mbox = do
    (ErlTuple [
        from@(ErlPid (ErlAtom node) a b c),
        msg@(ErlTuple [_,ErlTuple [_,ref],ErlTuple [
            -- [ErlAtom "call",ErlAtom "mod",ErlAtom "fun",ErlList [ErlAtom "args"]
                                                        call, --ErlAtom "call",
                                                        ErlAtom modName,
                                                        ErlAtom funName,
                                                        args,
                                                        _ --from@(ErlPid (ErlAtom node) a b c)
                                                    ]
            ])
        ]) <- mboxRecv mbox
    debugM "Test" $ "rpc " ++ modName ++ ":" ++ funName ++ "(" ++ (show args) ++ ")"
    mboxSend mbox node (Left from) $ ErlTuple [ref, ErlAtom "haskell_equals_very_yes"]
    rex mbox

#+END_SRC

Notice I'm just returning 'haskell_equals_very_yes' for
everything. I'm just excited that's working since it's my first stab
at Haskell. Plenty of future work here.

[[./img/erlang-haskell.gif]]

Fin.
